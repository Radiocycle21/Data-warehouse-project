/*
====================================================================================================================
-- Change-Over-Time -- 

Analyze how a measure evloves over time. 
helps track trends and identify seasonality in your data.  
====================================================================================================================
*/

-- Aanalyze the sales performance over time

select 
    year(order_date) as order_year,
    month(order_date) as order_month,
    sum(sales_amount) as total_sales,
    count(distinct customer_key) as total_customers,
    sum(Quantity) as total_quanity
from gold.fact_sales
where order_date is NOT NULL
group by month(order_date), year(order_date)
order by year(order_date), month(order_date);

select 
    datetrunc(month, order_date) as order_date,
    sum(sales_amount) as total_sales,
    count(distinct customer_key) as total_customers,
    sum(Quantity) as total_quanity
from gold.fact_sales
where order_date is NOT NULL
group by datetrunc(month, order_date)
order by  datetrunc(month, order_date);

select 
    format(order_date, 'yyyy-MMM') as order_date,
    sum(sales_amount) as total_sales,
    count(distinct customer_key) as total_customers,
    sum(Quantity) as total_quanity
from gold.fact_sales
where order_date is NOT NULL
group by format(order_date, 'yyyy-MMM')
order by  format(order_date, 'yyyy-MMM');

/*
====================================================================================================================
-- Cumulative Analysis -- 

Aggregate the data progressively overtime.
helps to understand whether our business is growing or declining.
====================================================================================================================
*/

-- calculate the total sales per month and the running total of sales over time.

select 
    order_date,
    total_sales,
    sum(total_sales) over (partition by order_date order by order_date) as running_total_sales
    from (
select 
    DATETRUNC(month, order_date) as order_date,
    sum(sales_amount) as total_sales
from gold.fact_sales
where order_date is NOT NULL
group by DATETRUNC(month, order_date)
)t

-- yearly running total
select 
    order_date,
    total_sales,
    sum(total_sales) over (order by order_date) as running_total_sales
    from (
select 
    DATETRUNC(year, order_date) as order_date,
    sum(sales_amount) as total_sales
from gold.fact_sales
where order_date is NOT NULL
group by DATETRUNC(year, order_date)
)t

-- moving average 

select 
    order_date,
    total_sales,
    sum(total_sales) over (order by order_date) as running_total_sales,
    Avg(total_sales) over (order by order_date) as moving_average_price
    from (
select 
    DATETRUNC(year, order_date) as order_date,
    sum(sales_amount) as total_sales,
    avg(price) as average_price
from gold.fact_sales
where order_date is NOT NULL
group by DATETRUNC(year, order_date)
)t

/*
====================================================================================================================
-- Performance Analysis -- 

Comparing the current value to a target value.
helps measure success and compare performance.
====================================================================================================================
*/

/*Analayze the yearly performance of products by comparing each product's sales to both 
it's average sales performance and the previous year's sales */

with yearly_product_sales as (
    select 
        year(f.order_date) as order_year,
        p.product_name,
        sum(f.sales_amount) as current_sales
    from gold.fact_sales f 
    left join gold.dim_products p 
    on f.product_key = p.product_key
    where f.order_date is NOT NULL
    group by 
    year(f.order_date),
    p.product_name
)
select 
    order_year,
    product_name,
    current_sales,
    avg(current_sales) over(partition by product_name)  as avg_sales,
    current_sales- avg(current_sales) over(partition by product_name) as diff_avg,
    case 
        when current_sales- avg(current_sales) over(partition by product_name) > 0 then 'Above Avg'
        when current_sales- avg(current_sales) over(partition by product_name) < 0 then 'Below Avg'
        else 'Avg'
    end as avg_change,
    lag(current_sales) over(partition by product_name order by order_year) as py_sales,
    current_sales -  lag(current_sales) over(partition by product_name order by order_year) as diff_py,
    case 
        when current_sales- lag(current_sales) over(partition by product_name order by order_year) > 0 then 'Increase'
        when current_sales- lag(current_sales) over(partition by product_name order by order_year) < 0 then 'Decrease'
        else 'No Change'
    end as py_change
from yearly_product_sales
order by product_name, order_year;


/*
====================================================================================================================
-- Part-To-Whole Analysis -- 

Analyze how an individual part is performing compared to the overall, 
allowing us to understand which category has the greatest impact on the business. 
====================================================================================================================
*/

-- which categories contirbute the most to overall sales? 

with category_sales as (
select 
    category,
    sum(sales_amount) as total_sales
from gold.fact_sales f
left join gold.dim_products p 
on p.product_key = f.product_key
group by category
)
select 
    category,
    total_sales,
    sum(total_sales) over () as overall_sales,
    concat(round((cast(total_sales as float) / sum(total_sales) over ())* 100, 2), '%') as percentage_of_total
from category_sales
order by total_sales desc;

/*
====================================================================================================================
-- Data Segmentation Analysis -- 

Group the data based on a specific range.
helps understand the correlation between two measures 
====================================================================================================================
*/

-- segemnt products into cost ranges and count how many products fall into each segment

with product_segment as (
select 
    product_key,
    product_name,
    cost,
    case  
        when cost < 100 then 'Below 100'
        when cost between 100 and 500 then '100-500'
        when cost between 500 and 1000 then '500-1000'
        else 'above 1000'
    end as cost_range
from gold.dim_products
) 
select 
    cost_range,
    count(product_key) as total_products 
from product_segment
group by cost_range 
order by total_products desc;

/* 
group customers into three segments based on their spending behavior: 
    - VIP: customers with at least 12 months of history and spending with more thatn $5,000.
    - Regular: customers with at least 12 months of history but spending $5,000 or less.
    - New: customers with a lifespan less than 12 months.
and find the total number of customers by each group 
*/

with customer_spending as (
select 
    c.customer_key,
    sum(f.sales_amount) as total_spending,
    min(order_date) as first_order,
    max(order_date) as last_order,
    datediff (month, min(order_date), max(order_date)) as lifespan
from gold.fact_sales f 
left join gold.dim_customers c 
on f.customer_key = c.customer_key 
group by c.customer_key
)
select 
    customer_segment,
    count(customer_key) as total_customers
from (
    select 
        customer_key,
        case 
            when lifespan > 12 and total_spending > 5000 then 'VIP'
            when lifespan >= 12 and total_spending <= 5000 then 'Regular'
            else 'New'
        end customer_segment 
    from customer_spending ) t 
group by customer_segment
order by total_customers desc;

/*
====================================================================================================================
-- Customer Report -- 
====================================================================================================================
Purpose: 
    - This report consolidates key customer metrics and behaviors
Highlights: 
    1. Gathers essential fileds such as names, ages, and transaction details.
    2. segments customers into categories (VIP, Regular, New) and age groups.
    3. Aggregartes customer-level metrics: 
        - total orders
        -total sales
        - total quantity purchased
        -total products
        - lifespan (in months)
    4. Calculates valuable KPIs: 
        - recency (months since last order)
        - average order value 
        - average monthly spend
====================================================================================================================
*/

create view gold.report_customers as 
with base_query as( 
select 
    f.order_number,
    f.product_key,
    f.order_date,
    f.sales_amount,
    f.quantity,
    c.customer_key,
    c.customer_number,
    concat(c.first_name, ' ', c.last_name) as customer_name,
    datediff(year, c.birthdate, getdate()) as age
from gold.fact_sales f 
left join gold.dim_customers c  
on c.customer_key = f.customer_key
where order_date is not null 
),
customer_aggregation as (
select 
    customer_key,
    customer_number,
    customer_name,
    age,
    count(distinct order_number) as total_orders,
    sum(sales_amount) as total_sales,
    sum(quantity) as total_quantity,
    count(distinct product_key) as total_products,
    max(order_date) as last_order_date,
    datediff(month, min(order_date), max(order_date)) as lifespan
from base_query
group by 
     customer_key,
    customer_number,
    customer_name,
    age
)
select 
    customer_key,
    customer_number,
    customer_name,
    age,
    case 
        when age <20 then 'Under 20'
        when age between 20 and 29 then'20-29'
        when age between 30 and 39 then'30-39'
        when age between 40 and 49 then'40-49'
        else '50 and above'
    end as age_group,
    case 
        when lifespan > 12 and total_sales > 5000 then 'VIP'
        when lifespan >= 12 and total_sales <= 5000 then 'Regular'
        else 'New'
    end as customer_segment,
    last_order_date,
    datediff(month, last_order_date, getdate()) as recency,
    total_orders,
    total_sales,
    total_quantity,
    total_products,
    lifespan,
    case
        when total_orders = 0 then 0 
        else total_sales/total_orders 
    end as avg_order_value,
    case
        when lifespan = 0 then total_sales
        else total_sales/lifespan 
    end as avg_monthly_spend
from customer_aggregation;

select * from gold.report_customers;